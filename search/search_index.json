{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SignalRKore","text":""},{"location":"#overview","title":"Overview","text":"<p>SignalRKore is a Kotlin Multiplatform client library for ASP.NET Core SignalR. It enables real-time communication between clients and servers, allowing server-side code to push content to clients and vice-versa instantly.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Kotlin Multiplatform: Supports Android, JVM, and iOS platforms</li> <li>Coroutines: Uses Kotlin Coroutines for asynchronous operations</li> <li>Ktor: Built on top of Ktor for networking</li> <li>Kotlinx Serialization: Uses Kotlinx Serialization for JSON serialization</li> <li>Multiple Transports: Supports WebSockets, ServerSentEvents, and LongPolling</li> <li>Automatic Reconnect: Provides automatic reconnection functionality</li> <li>Streams: Supports streaming data between client and server</li> <li>Connection Status: Provides connection status monitoring</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Create a connection\nval connection = HubConnectionBuilder.create(\"http://localhost:5000/chat\")\n\n// Start the connection\nconnection.start()\n\n// Send a message to the server\nconnection.send(\"broadcastMessage\", \"User\", \"Hello, SignalR!\")\n\n// Receive messages from the server\nconnection.on(\"broadcastMessage\", String.serializer(), String.serializer()).collect { (user, message) -&gt;\n    println(\"$user says: $message\")\n}\n\n// Don't forget to stop the connection when done\nconnection.stop()\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out the Getting Started guide to learn how to add SignalRKore to your project and start using it.</p>"},{"location":"#license","title":"License","text":"<p>SignalRKore is released under the Apache 2.0 license.</p> <pre><code>Copyright 2023 Michal Lepicek\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"api/hub-connection-builder/","title":"HubConnectionBuilder","text":"<p>The <code>HubConnectionBuilder</code> class is used to create and configure instances of <code>HubConnection</code>. It provides a fluent API for setting various connection options.</p>"},{"location":"api/hub-connection-builder/#creating-a-connection","title":"Creating a Connection","text":"<p>The simplest way to create a connection is to use the <code>create</code> method:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\")\n</code></pre>"},{"location":"api/hub-connection-builder/#configuration-options","title":"Configuration Options","text":"<p>You can configure the connection by passing a lambda to the <code>create</code> method:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    transportEnum = TransportEnum.WebSockets\n    skipNegotiate = true\n    automaticReconnect = AutomaticReconnect.Active\n    handshakeResponseTimeout = 30.seconds\n}\n</code></pre>"},{"location":"api/hub-connection-builder/#transport","title":"Transport","text":"<p>You can specify which transport to use for the connection:</p> <pre><code>transportEnum = TransportEnum.WebSockets\n</code></pre> <p>Available transport options:</p> <ul> <li><code>TransportEnum.All</code> (default): Automatically selects the best available transport</li> <li><code>TransportEnum.WebSockets</code>: Uses WebSockets transport</li> <li><code>TransportEnum.ServerSentEvents</code>: Uses Server-Sent Events transport</li> <li><code>TransportEnum.LongPolling</code>: Uses Long Polling transport</li> </ul>"},{"location":"api/hub-connection-builder/#skip-negotiate","title":"Skip Negotiate","text":"<p>You can skip the negotiate step when using WebSockets:</p> <pre><code>skipNegotiate = true\n</code></pre> <p>Note: This option can only be used with WebSockets transport.</p>"},{"location":"api/hub-connection-builder/#automatic-reconnect","title":"Automatic Reconnect","text":"<p>You can configure automatic reconnection when the connection is lost:</p> <pre><code>automaticReconnect = AutomaticReconnect.Active\n</code></pre> <p>Available reconnect options:</p> <ul> <li><code>AutomaticReconnect.Inactive</code> (default): No automatic reconnection</li> <li><code>AutomaticReconnect.Active</code>: Basic reconnect policy (waits 0, 2, 10, and 30 seconds before each attempt)</li> <li><code>AutomaticReconnect.exponentialBackoff()</code>: Exponential backoff policy</li> <li><code>AutomaticReconnect.Custom</code>: Custom reconnect policy</li> </ul> <p>See Reconnection for more details on reconnection options.</p>"},{"location":"api/hub-connection-builder/#handshake-response-timeout","title":"Handshake Response Timeout","text":"<p>You can configure the timeout for the handshake response:</p> <pre><code>handshakeResponseTimeout = 30.seconds\n</code></pre>"},{"location":"api/hub-connection-builder/#http-headers","title":"HTTP Headers","text":"<p>You can add custom HTTP headers to the connection:</p> <pre><code>headers = mapOf(\n    \"Authorization\" to \"Bearer token\",\n    \"Custom-Header\" to \"Value\"\n)\n</code></pre>"},{"location":"api/hub-connection-builder/#access-token","title":"Access Token","text":"<p>You can provide an access token for authentication:</p> <pre><code>accessTokenProvider = { \"your-access-token\" }\n</code></pre> <p>This is a convenience property that sets the \"Authorization\" header with a \"Bearer\" prefix.</p>"},{"location":"api/hub-connection-builder/#http-client","title":"HTTP Client","text":"<p>You can provide a custom Ktor HTTP client:</p> <pre><code>httpClient = HttpClient(OkHttp) {\n    engine {\n        preconfigured = okHttpBuilder.build()\n    }\n}\n</code></pre> <p>Note: If you provide a custom HTTP client, make sure it has the necessary plugins installed:</p> <pre><code>HttpClient {\n    install(WebSockets)\n    install(SSE)\n    install(HttpTimeout)\n    install(ContentNegotiation) { json() }\n}\n</code></pre>"},{"location":"api/hub-connection-builder/#protocol","title":"Protocol","text":"<p>You can specify a custom hub protocol:</p> <pre><code>protocol = JsonHubProtocol()\n</code></pre>"},{"location":"api/hub-connection-builder/#json-serialization","title":"JSON Serialization","text":"<p>You can provide a custom JSON serializer:</p> <pre><code>json = Json {\n    ignoreUnknownKeys = true\n    isLenient = true\n    // Other configuration options\n}\n</code></pre>"},{"location":"api/hub-connection-builder/#logger","title":"Logger","text":"<p>You can provide a custom logger:</p> <pre><code>logger = Logger { severity, message, cause -&gt;\n    when (severity) {\n        Logger.Severity.INFO -&gt; println(\"INFO: $message\")\n        Logger.Severity.WARNING -&gt; println(\"WARNING: $message\")\n        Logger.Severity.ERROR -&gt; println(\"ERROR: $message, cause: $cause\")\n    }\n}\n</code></pre>"},{"location":"api/hub-connection-builder/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates all configuration options:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    transportEnum = TransportEnum.WebSockets\n    skipNegotiate = true\n    automaticReconnect = AutomaticReconnect.Active\n    handshakeResponseTimeout = 30.seconds\n    headers = mapOf(\"Custom-Header\" to \"Value\")\n    accessTokenProvider = { \"your-access-token\" }\n    httpClient = HttpClient {\n        install(WebSockets)\n        install(SSE)\n        install(HttpTimeout)\n        install(ContentNegotiation) { json() }\n    }\n    protocol = JsonHubProtocol()\n    json = Json {\n        ignoreUnknownKeys = true\n        isLenient = true\n    }\n    logger = Logger { severity, message, cause -&gt;\n        when (severity) {\n            Logger.Severity.INFO -&gt; println(\"INFO: $message\")\n            Logger.Severity.WARNING -&gt; println(\"WARNING: $message\")\n            Logger.Severity.ERROR -&gt; println(\"ERROR: $message, cause: $cause\")\n        }\n    }\n}\n</code></pre>"},{"location":"api/hub-connection-builder/#api-reference","title":"API Reference","text":""},{"location":"api/hub-connection-builder/#methods","title":"Methods","text":"Name Parameters Return Type Description <code>create</code> <code>url: String, configure: (HttpHubConnectionBuilder.() -&gt; Unit)? = null</code> <code>HubConnection</code> Creates a new HubConnection with the specified URL and configuration"},{"location":"api/hub-connection-builder/#httphubconnectionbuilder-properties","title":"HttpHubConnectionBuilder Properties","text":"Name Type Default Description <code>transportEnum</code> <code>TransportEnum</code> <code>TransportEnum.All</code> The transport type to use for the connection <code>skipNegotiate</code> <code>Boolean</code> <code>false</code> Whether to skip the negotiate step (WebSockets only) <code>automaticReconnect</code> <code>AutomaticReconnect</code> <code>AutomaticReconnect.Inactive</code> The automatic reconnect policy <code>handshakeResponseTimeout</code> <code>Duration</code> <code>15.seconds</code> The timeout for the handshake response <code>headers</code> <code>Map&lt;String, String&gt;</code> <code>emptyMap()</code> HTTP headers to include in requests <code>accessTokenProvider</code> <code>(suspend () -&gt; String)?</code> <code>null</code> Access token for authentication (sets the \"Authorization\" header with \"Bearer\" prefix) <code>httpClient</code> <code>HttpClient?</code> <code>null</code> Custom Ktor HTTP client <code>protocol</code> <code>HubProtocol</code> <code>JsonHubProtocol()</code> The protocol used for communication with the hub <code>json</code> <code>Json</code> <code>Json { ignoreUnknownKeys = true }</code> JSON serializer <code>logger</code> <code>Logger</code> <code>Logger.Empty</code> Logger for logging messages"},{"location":"api/hub-connection/","title":"HubConnection","text":"<p>The <code>HubConnection</code> class is the main entry point for interacting with a SignalR hub. It provides methods for starting and stopping the connection, sending and receiving messages, and monitoring the connection status.</p>"},{"location":"api/hub-connection/#creating-a-connection","title":"Creating a Connection","text":"<p>You don't create a <code>HubConnection</code> instance directly. Instead, use the <code>HubConnectionBuilder</code> class:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\")\n</code></pre> <p>See HubConnectionBuilder for more details on configuration options.</p>"},{"location":"api/hub-connection/#connection-lifecycle","title":"Connection Lifecycle","text":""},{"location":"api/hub-connection/#starting-a-connection","title":"Starting a Connection","text":"<p>Before you can send or receive messages, you need to start the connection:</p> <pre><code>// In a coroutine scope\nconnection.start()\n</code></pre> <p>This method is suspending and will complete when the connection is established or throw an exception if the connection fails.</p>"},{"location":"api/hub-connection/#monitoring-connection-state","title":"Monitoring Connection State","text":"<p>You can monitor the connection state using the <code>connectionState</code> property:</p> <pre><code>connection.connectionState.collect { state -&gt;\n    when (state) {\n        HubConnectionState.CONNECTED -&gt; println(\"Connected to the hub\")\n        HubConnectionState.CONNECTING -&gt; println(\"Connecting to the hub\")\n        HubConnectionState.DISCONNECTED -&gt; println(\"Disconnected from the hub\")\n        HubConnectionState.RECONNECTING -&gt; println(\"Reconnecting to the hub\")\n    }\n}\n</code></pre>"},{"location":"api/hub-connection/#stopping-a-connection","title":"Stopping a Connection","text":"<p>When you're done with the connection, you should stop it:</p> <pre><code>connection.stop()\n</code></pre> <p>You can optionally provide an error message:</p> <pre><code>connection.stop(\"Connection closed by user\")\n</code></pre>"},{"location":"api/hub-connection/#sending-messages","title":"Sending Messages","text":""},{"location":"api/hub-connection/#send-method","title":"Send Method","text":"<p>The <code>send</code> method sends a message to the hub without expecting a response:</p> <pre><code>// Send a message with parameters\nconnection.send(\"broadcastMessage\", \"User\", \"Hello, SignalR!\")\n</code></pre>"},{"location":"api/hub-connection/#invoke-method","title":"Invoke Method","text":"<p>The <code>invoke</code> method sends a message to the hub and expects a response:</p> <pre><code>// Invoke a method and get the result\nval result = connection.invoke(\"echo\", String.serializer(), \"Hello, SignalR!\")\nprintln(\"Server responded: $result\")\n</code></pre>"},{"location":"api/hub-connection/#receiving-messages","title":"Receiving Messages","text":""},{"location":"api/hub-connection/#on-method","title":"On Method","text":"<p>The <code>on</code> method registers a handler for a specific hub method:</p> <pre><code>// Receive a message with two parameters\nconnection.on(\"broadcastMessage\", String.serializer(), String.serializer()).collect { (user, message) -&gt;\n    println(\"$user says: $message\")\n}\n</code></pre>"},{"location":"api/hub-connection/#receiving-complex-types","title":"Receiving Complex Types","text":"<p>You can also receive messages with complex types:</p> <pre><code>@Serializable\ndata class ChatMessage(\n    val user: String,\n    val message: String,\n    val timestamp: String\n)\n\nconnection.on(\"receiveMessage\", ChatMessage.serializer()).collect { (message) -&gt;\n    println(\"${message.user} says: ${message.message} at ${message.timestamp}\")\n}\n</code></pre>"},{"location":"api/hub-connection/#working-with-streams","title":"Working with Streams","text":""},{"location":"api/hub-connection/#receiving-a-stream","title":"Receiving a Stream","text":"<p>The <code>stream</code> method allows you to receive a stream of data from the hub:</p> <pre><code>connection.stream(\"counterStream\", Int.serializer(), 10, 1000).collect { count -&gt;\n    println(\"Received count: $count\")\n}\n</code></pre>"},{"location":"api/hub-connection/#sending-a-stream","title":"Sending a Stream","text":"<p>You can send a stream of data to the hub using a Flow:</p> <pre><code>val dataStream = flow {\n    for (i in 1..10) {\n        emit(i)\n        delay(1000)\n    }\n}\n\nconnection.send(\"uploadStream\", dataStream)\n</code></pre>"},{"location":"api/hub-connection/#automatic-reconnection","title":"Automatic Reconnection","text":"<p>SignalRKore supports automatic reconnection when the connection is lost. This is configured through the <code>HubConnectionBuilder</code>:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    automaticReconnect = AutomaticReconnect.Active\n}\n</code></pre> <p>See Reconnection for more details on reconnection options.</p>"},{"location":"api/hub-connection/#api-reference","title":"API Reference","text":""},{"location":"api/hub-connection/#properties","title":"Properties","text":"Name Type Description <code>connectionState</code> <code>StateFlow&lt;HubConnectionState&gt;</code> The current state of the connection"},{"location":"api/hub-connection/#methods","title":"Methods","text":"Name Parameters Return Type Description <code>start</code> <code>reconnectionAttempt: Boolean = false</code> <code>Unit</code> Starts the connection to the hub <code>stop</code> <code>errorMessage: String? = null</code> <code>Unit</code> Stops the connection to the hub <code>send</code> <code>method: String, vararg args: Any?</code> <code>Unit</code> Sends a message to the hub without expecting a response <code>invoke</code> <code>method: String, resultType: KSerializer&lt;T&gt;, vararg args: Any?</code> <code>T</code> Sends a message to the hub and expects a response <code>on</code> <code>method: String, paramType1: KSerializer&lt;T1&gt;, paramType2: KSerializer&lt;T2&gt;, ...</code> <code>Flow&lt;Tuple&gt;</code> Registers a handler for a specific hub method <code>stream</code> <code>method: String, itemType: KSerializer&lt;T&gt;, vararg args: Any?</code> <code>Flow&lt;T&gt;</code> Receives a stream of data from the hub"},{"location":"api/hub-connection/#enums","title":"Enums","text":""},{"location":"api/hub-connection/#hubconnectionstate","title":"HubConnectionState","text":"Value Description <code>CONNECTED</code> The connection is connected to the hub <code>CONNECTING</code> The connection is connecting to the hub <code>DISCONNECTED</code> The connection is disconnected from the hub <code>RECONNECTING</code> The connection is reconnecting to the hub"},{"location":"api/protocol/","title":"Protocol","text":"<p>The <code>HubProtocol</code> interface defines the contract for protocols used by SignalRKore to serialize and deserialize messages sent between the client and the server. SignalRKore currently provides one implementation of this interface: <code>JsonHubProtocol</code>.</p>"},{"location":"api/protocol/#hubprotocol-interface","title":"HubProtocol Interface","text":"<p>The <code>HubProtocol</code> interface defines the following properties and methods:</p> <pre><code>interface HubProtocol {\n    val name: String\n    val version: Int\n    val transferFormat: TransferFormat\n\n    fun parseMessages(payload: ByteArray): List&lt;HubMessage&gt;\n    fun writeMessage(message: HubMessage): ByteArray\n}\n</code></pre>"},{"location":"api/protocol/#jsonhubprotocol","title":"JsonHubProtocol","text":"<p>The <code>JsonHubProtocol</code> class is the default implementation of the <code>HubProtocol</code> interface. It uses JSON for serialization and deserialization of messages.</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    protocol = JsonHubProtocol()  // Default\n}\n</code></pre>"},{"location":"api/protocol/#custom-protocol","title":"Custom Protocol","text":"<p>You can implement your own protocol by implementing the <code>HubProtocol</code> interface. This is an advanced use case and is not typically needed.</p> <pre><code>class MyHubProtocol : HubProtocol {\n    override val name: String = \"my-protocol\"\n    override val version: Int = 1\n    override val transferFormat: TransferFormat = TransferFormat.Text\n\n    override fun parseMessages(payload: ByteArray): List&lt;HubMessage&gt; {\n        // Your implementation\n    }\n\n    override fun writeMessage(message: HubMessage): ByteArray {\n        // Your implementation\n    }\n}\n\nval connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    protocol = MyHubProtocol()\n}\n</code></pre>"},{"location":"api/protocol/#hubmessage","title":"HubMessage","text":"<p>The <code>HubMessage</code> sealed class represents messages sent between the client and the server. It has several subclasses for different types of messages:</p> <ul> <li><code>HubMessage.Invocation</code>: Represents an invocation of a hub method</li> <li><code>HubMessage.StreamInvocation</code>: Represents an invocation of a streaming hub method</li> <li><code>HubMessage.StreamItem</code>: Represents an item in a stream</li> <li><code>HubMessage.Completion</code>: Represents the completion of a hub method invocation</li> <li><code>HubMessage.Ping</code>: Represents a ping message</li> <li><code>HubMessage.Close</code>: Represents a close message</li> <li><code>HubMessage.CancelInvocation</code>: Represents a cancellation of a streaming hub method invocation</li> </ul>"},{"location":"api/protocol/#transferformat","title":"TransferFormat","text":"<p>The <code>TransferFormat</code> enum defines the format in which messages are transferred:</p> <pre><code>enum class TransferFormat {\n    Text,\n    Binary\n}\n</code></pre>"},{"location":"api/protocol/#api-reference","title":"API Reference","text":""},{"location":"api/protocol/#hubprotocol-interface_1","title":"HubProtocol Interface","text":""},{"location":"api/protocol/#properties","title":"Properties","text":"Name Type Description <code>name</code> <code>String</code> The name of the protocol <code>version</code> <code>Int</code> The version of the protocol <code>transferFormat</code> <code>TransferFormat</code> The format in which messages are transferred"},{"location":"api/protocol/#methods","title":"Methods","text":"Name Parameters Return Type Description <code>parseMessages</code> <code>payload: ByteArray</code> <code>List&lt;HubMessage&gt;</code> Parses messages from a byte array <code>writeMessage</code> <code>message: HubMessage</code> <code>ByteArray</code> Writes a message to a byte array"},{"location":"api/protocol/#jsonhubprotocol_1","title":"JsonHubProtocol","text":"<p>The <code>JsonHubProtocol</code> class is the default implementation of the <code>HubProtocol</code> interface. It uses JSON for serialization and deserialization of messages.</p>"},{"location":"api/protocol/#properties_1","title":"Properties","text":"Name Type Value Description <code>name</code> <code>String</code> <code>\"json\"</code> The name of the protocol <code>version</code> <code>Int</code> <code>1</code> The version of the protocol <code>transferFormat</code> <code>TransferFormat</code> <code>TransferFormat.Text</code> The format in which messages are transferred"},{"location":"api/protocol/#transferformat_1","title":"TransferFormat","text":"Value Description <code>Text</code> Messages are transferred as text <code>Binary</code> Messages are transferred as binary data"},{"location":"api/protocol/#implementation-details","title":"Implementation Details","text":"<p>The <code>JsonHubProtocol</code> class uses Kotlinx Serialization for JSON serialization and deserialization. It handles the following message types:</p> <ul> <li>Invocation</li> <li>StreamInvocation</li> <li>StreamItem</li> <li>Completion</li> <li>Ping</li> <li>Close</li> <li>CancelInvocation</li> </ul> <p>Each message type has a specific format defined by the SignalR protocol. The <code>JsonHubProtocol</code> class handles the serialization and deserialization of these messages according to the protocol specification.</p> <p>For more details on the SignalR protocol, see the official documentation.</p>"},{"location":"api/transport/","title":"Transport","text":"<p>The <code>Transport</code> interface defines the contract for different transport mechanisms used by SignalRKore to communicate with a SignalR hub. SignalRKore supports three transport types: WebSockets, Server-Sent Events (SSE), and Long Polling.</p>"},{"location":"api/transport/#transport-interface","title":"Transport Interface","text":"<p>The <code>Transport</code> interface defines the following methods:</p> <pre><code>interface Transport {\n    suspend fun start(url: String)\n    suspend fun send(data: ByteArray)\n    fun receive(): Flow&lt;ByteArray&gt;\n    suspend fun stop()\n}\n</code></pre>"},{"location":"api/transport/#transport-types","title":"Transport Types","text":""},{"location":"api/transport/#websockets","title":"WebSockets","text":"<p>WebSockets is a protocol providing full-duplex communication channels over a single TCP connection. It's the preferred transport for SignalR as it provides the most efficient communication.</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    transportEnum = TransportEnum.WebSockets\n}\n</code></pre>"},{"location":"api/transport/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>Server-Sent Events is a technology where a browser receives automatic updates from a server via HTTP connection. It's a one-way communication channel from the server to the client.</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    transportEnum = TransportEnum.ServerSentEvents\n}\n</code></pre>"},{"location":"api/transport/#long-polling","title":"Long Polling","text":"<p>Long Polling is a technique where the client makes an HTTP request to the server, and the server keeps the connection open until it has new data to send. Once the server sends a response, the client immediately makes a new request.</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    transportEnum = TransportEnum.LongPolling\n}\n</code></pre>"},{"location":"api/transport/#automatic-transport-selection","title":"Automatic Transport Selection","text":"<p>By default, SignalRKore will automatically select the best available transport based on what the server supports. The order of preference is:</p> <ol> <li>WebSockets</li> <li>Server-Sent Events</li> <li>Long Polling</li> </ol> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    transportEnum = TransportEnum.All  // Default\n}\n</code></pre>"},{"location":"api/transport/#transport-fallback","title":"Transport Fallback","text":"<p>Currently, SignalRKore does not support automatic transport fallback. If a transport fails to connect, the connection will fail. You need to handle reconnection manually or use the automatic reconnect feature.</p>"},{"location":"api/transport/#custom-transport","title":"Custom Transport","text":"<p>You can implement your own transport by implementing the <code>Transport</code> interface. However, this is an advanced use case and is not typically needed.</p>"},{"location":"api/transport/#transportenum","title":"TransportEnum","text":"<p>The <code>TransportEnum</code> enum defines the available transport types:</p> <pre><code>enum class TransportEnum {\n    All,\n    WebSockets,\n    ServerSentEvents,\n    LongPolling\n}\n</code></pre>"},{"location":"api/transport/#api-reference","title":"API Reference","text":""},{"location":"api/transport/#transport-interface_1","title":"Transport Interface","text":"Method Parameters Return Type Description <code>start</code> <code>url: String</code> <code>Unit</code> Starts the transport with the specified URL <code>send</code> <code>data: ByteArray</code> <code>Unit</code> Sends data to the server <code>receive</code> None <code>Flow&lt;ByteArray&gt;</code> Receives data from the server as a flow <code>stop</code> None <code>Unit</code> Stops the transport"},{"location":"api/transport/#transportenum_1","title":"TransportEnum","text":"Value Description <code>All</code> Automatically selects the best available transport <code>WebSockets</code> Uses WebSockets transport <code>ServerSentEvents</code> Uses Server-Sent Events transport <code>LongPolling</code> Uses Long Polling transport"},{"location":"api/transport/#implementation-details","title":"Implementation Details","text":"<p>SignalRKore provides three implementations of the <code>Transport</code> interface:</p> <ul> <li><code>WebSocketTransport</code>: Uses Ktor's WebSockets client</li> <li><code>ServerSentEventsTransport</code>: Uses Ktor's SSE client</li> <li><code>LongPollingTransport</code>: Uses Ktor's HTTP client for long polling</li> </ul> <p>These implementations are internal to the library and are not meant to be used directly. Instead, you should use the <code>HubConnectionBuilder</code> to create a connection with the desired transport type.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>SignalRKore is available on Maven Central. You can add it to your project using Gradle or Maven.</p>"},{"location":"getting-started/installation/#gradle","title":"Gradle","text":""},{"location":"getting-started/installation/#kotlin-dsl","title":"Kotlin DSL","text":"<p>Add the following to your <code>build.gradle.kts</code> file:</p> <pre><code>dependencies {\n    implementation(\"eu.lepicekmichal.signalrkore:signalrkore:${signalrkoreVersion}\")\n}\n</code></pre>"},{"location":"getting-started/installation/#groovy-dsl","title":"Groovy DSL","text":"<p>Add the following to your <code>build.gradle</code> file:</p> <pre><code>dependencies {\n    implementation \"eu.lepicekmichal.signalrkore:signalrkore:${signalrkoreVersion}\"\n}\n</code></pre>"},{"location":"getting-started/installation/#maven","title":"Maven","text":"<p>Add the following to your <code>pom.xml</code> file:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.lepicekmichal.signalrkore&lt;/groupId&gt;\n    &lt;artifactId&gt;signalrkore&lt;/artifactId&gt;\n    &lt;version&gt;${signalrkoreVersion}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/installation/#multiplatform-setup","title":"Multiplatform Setup","text":"<p>SignalRKore is a Kotlin Multiplatform library that supports Android, JVM, and iOS platforms.</p>"},{"location":"getting-started/installation/#android","title":"Android","text":"<p>No additional setup is required for Android projects. Just add the dependency as shown above.</p>"},{"location":"getting-started/installation/#jvm","title":"JVM","text":"<p>No additional setup is required for JVM projects. Just add the dependency as shown above.</p>"},{"location":"getting-started/installation/#ios","title":"iOS","text":"<p>For iOS projects, you need to include the SignalRKore framework in your Xcode project.</p>"},{"location":"getting-started/installation/#swift-package-manager","title":"Swift Package Manager","text":"<p>Currently, SignalRKore is not available via Swift Package Manager. You need to use Kotlin Multiplatform Mobile (KMM) to include it in your iOS project.</p>"},{"location":"getting-started/installation/#kotlin-multiplatform-mobile-kmm","title":"Kotlin Multiplatform Mobile (KMM)","text":"<p>If you're using KMM, you can add SignalRKore as a dependency to your shared module:</p> <pre><code>kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(\"eu.lepicekmichal.signalrkore:signalrkore:${signalrkoreVersion}\")\n            }\n        }\n    }\n}\n</code></pre> <p>Then, you can access SignalRKore from your iOS app through the shared module.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Kotlin 2.0.0 or higher</li> <li>Ktor 3.0.0 or higher</li> <li>Kotlinx Serialization 1.7.0 or higher</li> <li>Kotlinx Coroutines 1.9.0 or higher</li> </ul>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once you have added SignalRKore to your project, you can proceed to the Quick Start guide to learn how to use it.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will help you get started with SignalRKore by walking you through the basic steps to connect to a SignalR hub, send and receive messages.</p>"},{"location":"getting-started/quick-start/#creating-a-connection","title":"Creating a Connection","text":"<p>The first step is to create a connection to a SignalR hub using the <code>HubConnectionBuilder</code>:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\")\n</code></pre>"},{"location":"getting-started/quick-start/#starting-the-connection","title":"Starting the Connection","text":"<p>Before you can send or receive messages, you need to start the connection:</p> <pre><code>// In a coroutine scope\nconnection.start()\n</code></pre> <p>You can also check the connection state:</p> <pre><code>connection.connectionState.collect { state -&gt;\n    when (state) {\n        HubConnectionState.CONNECTED -&gt; println(\"Connected to the hub\")\n        HubConnectionState.CONNECTING -&gt; println(\"Connecting to the hub\")\n        HubConnectionState.DISCONNECTED -&gt; println(\"Disconnected from the hub\")\n        HubConnectionState.RECONNECTING -&gt; println(\"Reconnecting to the hub\")\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#sending-messages","title":"Sending Messages","text":"<p>Once connected, you can send messages to the hub using the <code>send</code> or <code>invoke</code> methods:</p>"},{"location":"getting-started/quick-start/#send-method","title":"Send Method","text":"<p>The <code>send</code> method sends a message to the hub without expecting a response:</p> <pre><code>// Send a message with parameters\nconnection.send(\"broadcastMessage\", \"User\", \"Hello, SignalR!\")\n</code></pre>"},{"location":"getting-started/quick-start/#invoke-method","title":"Invoke Method","text":"<p>The <code>invoke</code> method sends a message to the hub and expects a response:</p> <pre><code>// Invoke a method and get the result\nval result = connection.invoke(\"echo\", String.serializer(), \"Hello, SignalR!\")\nprintln(\"Server responded: $result\")\n</code></pre>"},{"location":"getting-started/quick-start/#receiving-messages","title":"Receiving Messages","text":"<p>To receive messages from the hub, use the <code>on</code> method:</p> <pre><code>// Receive a message with two parameters\nconnection.on(\"broadcastMessage\", String.serializer(), String.serializer()).collect { (user, message) -&gt;\n    println(\"$user says: $message\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#receiving-messages-with-complex-types","title":"Receiving Messages with Complex Types","text":"<p>You can also receive messages with complex types:</p> <pre><code>@Serializable\ndata class ChatMessage(\n    val user: String,\n    val message: String,\n    val timestamp: String\n)\n\nconnection.on(\"receiveMessage\", ChatMessage.serializer()).collect { (message) -&gt;\n    println(\"${message.user} says: ${message.message} at ${message.timestamp}\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#working-with-streams","title":"Working with Streams","text":"<p>SignalRKore supports streaming data between client and server:</p>"},{"location":"getting-started/quick-start/#receiving-a-stream","title":"Receiving a Stream","text":"<pre><code>connection.stream(\"counterStream\", Int.serializer(), 10, 1000).collect { count -&gt;\n    println(\"Received count: $count\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#sending-a-stream","title":"Sending a Stream","text":"<pre><code>// Create a flow that emits 10 integers with a 1-second delay between each\nval dataStream = flow {\n    for (i in 1..10) {\n        emit(i)\n        delay(1000)\n    }\n}\n\nconnection.send(\"uploadStream\", dataStream)\n</code></pre>"},{"location":"getting-started/quick-start/#stopping-the-connection","title":"Stopping the Connection","text":"<p>When you're done, don't forget to stop the connection:</p> <pre><code>connection.stop()\n</code></pre>"},{"location":"getting-started/quick-start/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates the basic usage of SignalRKore:</p> <pre><code>// Define a serializable message class\n@Serializable\ndata class ChatMessage(\n    val user: String,\n    val message: String,\n    val timestamp: String\n)\n\nfun main() {\n    // Create a coroutine scope\n    val scope = CoroutineScope(Dispatchers.Main)\n\n    // Create a connection\n    val connection = HubConnectionBuilder.create(\"https://example.com/chathub\")\n\n    // Monitor connection state\n    scope.launch {\n        connection.connectionState.collect { state -&gt;\n            println(\"Connection state: $state\")\n        }\n    }\n\n    // Start the connection\n    scope.launch {\n        connection.start()\n\n        // Send a message\n        connection.send(\"broadcastMessage\", \"User\", \"Hello, SignalR!\")\n\n        // Receive messages\n        connection.on(\"broadcastMessage\", String.serializer(), String.serializer()).collect { (user, message) -&gt;\n            println(\"$user says: $message\")\n        }\n\n        // Receive messages with complex types\n        connection.on(\"receiveMessage\", ChatMessage.serializer()).collect { (message) -&gt;\n            println(\"${message.user} says: ${message.message} at ${message.timestamp}\")\n        }\n\n        // Stop the connection when done\n        connection.stop()\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of how to use SignalRKore, you can explore the User Guide for more detailed information on each feature.</p>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>This guide explains the various configuration options available in SignalRKore. These options allow you to customize the behavior of the SignalR client to suit your needs.</p>"},{"location":"user-guide/configuration/#hubconnectionbuilder","title":"HubConnectionBuilder","text":"<p>All configuration options are set through the <code>HubConnectionBuilder</code> when creating a connection:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    // Configuration options go here\n}\n</code></pre>"},{"location":"user-guide/configuration/#transport-options","title":"Transport Options","text":""},{"location":"user-guide/configuration/#transport-type","title":"Transport Type","text":"<p>You can specify which transport to use for the connection:</p> <pre><code>transportEnum = TransportEnum.WebSockets\n</code></pre> <p>Available transport options:</p> <ul> <li><code>TransportEnum.All</code> (default): Automatically selects the best available transport</li> <li><code>TransportEnum.WebSockets</code>: Uses WebSockets transport</li> <li><code>TransportEnum.ServerSentEvents</code>: Uses Server-Sent Events transport</li> <li><code>TransportEnum.LongPolling</code>: Uses Long Polling transport</li> </ul> <p>See the Transport API reference for more details.</p>"},{"location":"user-guide/configuration/#skip-negotiate","title":"Skip Negotiate","text":"<p>You can skip the negotiate step when using WebSockets:</p> <pre><code>skipNegotiate = true\n</code></pre> <p>Note: This option can only be used with WebSockets transport.</p>"},{"location":"user-guide/configuration/#authentication-and-headers","title":"Authentication and Headers","text":""},{"location":"user-guide/configuration/#http-headers","title":"HTTP Headers","text":"<p>You can add custom HTTP headers to the connection:</p> <pre><code>headers = mapOf(\n    \"Authorization\" to \"Bearer token\",\n    \"Custom-Header\" to \"Value\"\n)\n</code></pre>"},{"location":"user-guide/configuration/#access-token","title":"Access Token","text":"<p>You can provide an access token for authentication:</p> <pre><code>accessTokenProvider = { \"your-access-token\" }\n</code></pre> <p>This is a convenience property that sets the \"Authorization\" header with a \"Bearer\" prefix. It's equivalent to:</p> <pre><code>headers[\"Authorization\"] = \"Bearer your-access-token\"\n</code></pre> <p>This is useful for JWT authentication.</p>"},{"location":"user-guide/configuration/#timeout-and-reconnection","title":"Timeout and Reconnection","text":""},{"location":"user-guide/configuration/#handshake-response-timeout","title":"Handshake Response Timeout","text":"<p>You can configure the timeout for the handshake response:</p> <pre><code>handshakeResponseTimeout = 30.seconds\n</code></pre>"},{"location":"user-guide/configuration/#automatic-reconnect","title":"Automatic Reconnect","text":"<p>You can configure automatic reconnection when the connection is lost:</p> <pre><code>automaticReconnect = AutomaticReconnect.Active\n</code></pre> <p>See the Reconnection guide for more details on reconnection options.</p>"},{"location":"user-guide/configuration/#http-client","title":"HTTP Client","text":""},{"location":"user-guide/configuration/#custom-http-client","title":"Custom HTTP Client","text":"<p>You can provide a custom Ktor HTTP client:</p> <pre><code>httpClient = HttpClient {\n    install(WebSockets)\n    install(SSE)\n    install(HttpTimeout)\n    install(ContentNegotiation) { json() }\n}\n</code></pre> <p>This is useful if you need to configure the HTTP client with custom settings or plugins.</p> <p>Warning: If you provide a custom HTTP client, you must install all the necessary plugins. At a minimum, you need to install: - <code>WebSockets</code> - Required for WebSockets transport - <code>SSE</code> - Required for Server-Sent Events transport - <code>HttpTimeout</code> - Required for timeout handling - <code>ContentNegotiation</code> with JSON - Required for serialization</p> <p>Failure to install these plugins may result in runtime errors.</p>"},{"location":"user-guide/configuration/#okhttp-engine","title":"OkHttp Engine","text":"<p>If you're using the JVM or Android platform, you can configure the OkHttp engine:</p> <pre><code>val okHttpClient = OkHttpClient.Builder()\n    .connectTimeout(30, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .writeTimeout(30, TimeUnit.SECONDS)\n    .build()\n\nhttpClient = HttpClient(OkHttp) {\n    engine {\n        preconfigured = okHttpClient\n    }\n    install(WebSockets)\n    install(SSE)\n    install(HttpTimeout)\n    install(ContentNegotiation) { json() }\n}\n</code></pre>"},{"location":"user-guide/configuration/#protocol-and-serialization","title":"Protocol and Serialization","text":""},{"location":"user-guide/configuration/#protocol","title":"Protocol","text":"<p>You can specify a custom hub protocol:</p> <pre><code>protocol = JsonHubProtocol()\n</code></pre> <p>Currently, only the <code>JsonHubProtocol</code> is supported.</p> <p>See the Protocol API reference for more details.</p>"},{"location":"user-guide/configuration/#json-serialization","title":"JSON Serialization","text":"<p>You can provide a custom JSON serializer:</p> <pre><code>json = Json {\n    ignoreUnknownKeys = true\n    isLenient = true\n    // Other configuration options\n}\n</code></pre> <p>This is useful if you need to configure the JSON serializer with custom settings or modules.</p> <p>For example, you can register custom serializers for specific types:</p> <pre><code>json = Json {\n    ignoreUnknownKeys = true\n    serializersModule = SerializersModule {\n        contextual(Date::class) { DateSerializer }\n        contextual(UUID::class) { UUIDSerializer }\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#logging","title":"Logging","text":""},{"location":"user-guide/configuration/#custom-logger","title":"Custom Logger","text":"<p>You can provide a custom logger:</p> <pre><code>logger = Logger { severity, message, cause -&gt;\n    when (severity) {\n        Logger.Severity.INFO -&gt; println(\"INFO: $message\")\n        Logger.Severity.WARNING -&gt; println(\"WARNING: $message\")\n        Logger.Severity.ERROR -&gt; println(\"ERROR: $message, cause: $cause\")\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#integration-with-logging-frameworks","title":"Integration with Logging Frameworks","text":"<p>You can integrate with popular logging frameworks:</p>"},{"location":"user-guide/configuration/#napier-multiplatform","title":"Napier (Multiplatform)","text":"<pre><code>logger = Logger { severity, message, cause -&gt;\n    when (severity) {\n        Logger.Severity.INFO -&gt; Napier.i(message)\n        Logger.Severity.WARNING -&gt; Napier.w(message)\n        Logger.Severity.ERROR -&gt; Napier.e(cause, message)\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#other-logging-frameworks","title":"Other Logging Frameworks","text":"<p>For other logging frameworks like SLF4J or Timber, you can use a similar approach:</p> <pre><code>// SLF4J\nlogger = Logger { severity, message, cause -&gt;\n    val logger = LoggerFactory.getLogger(\"SignalRKore\")\n    when (severity) {\n        Logger.Severity.INFO -&gt; logger.info(message)\n        Logger.Severity.WARNING -&gt; logger.warn(message)\n        Logger.Severity.ERROR -&gt; logger.error(message, cause)\n    }\n}\n\n// Timber (Android)\nlogger = Logger { severity, message, cause -&gt;\n    when (severity) {\n        Logger.Severity.INFO -&gt; Timber.i(message)\n        Logger.Severity.WARNING -&gt; Timber.w(message)\n        Logger.Severity.ERROR -&gt; Timber.e(cause, message)\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates all configuration options:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    // Transport options\n    transportEnum = TransportEnum.WebSockets\n    skipNegotiate = true\n\n    // Authentication and headers\n    headers = mapOf(\"Custom-Header\" to \"Value\")\n    accessTokenProvider = { \"your-access-token\" }\n\n    // Timeout and reconnection\n    handshakeResponseTimeout = 30.seconds\n    automaticReconnect = AutomaticReconnect.exponentialBackoff()\n\n    // HTTP client\n    httpClient = HttpClient {\n        install(WebSockets)\n        install(SSE)\n        install(HttpTimeout)\n        install(ContentNegotiation) { json() }\n    }\n\n    // Protocol and serialization\n    protocol = JsonHubProtocol()\n    json = Json {\n        ignoreUnknownKeys = true\n        isLenient = true\n    }\n\n    // Logging\n    logger = Logger { severity, message, cause -&gt;\n        when (severity) {\n            Logger.Severity.INFO -&gt; println(\"INFO: $message\")\n            Logger.Severity.WARNING -&gt; println(\"WARNING: $message\")\n            Logger.Severity.ERROR -&gt; println(\"ERROR: $message, cause: $cause\")\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#platform-specific-configuration","title":"Platform-Specific Configuration","text":""},{"location":"user-guide/configuration/#android","title":"Android","text":"<p>On Android, you might want to use the Android-specific HTTP client:</p> <pre><code>httpClient = HttpClient(Android) {\n    install(WebSockets)\n    install(SSE)\n    install(HttpTimeout)\n    install(ContentNegotiation) { json() }\n}\n</code></pre>"},{"location":"user-guide/configuration/#ios","title":"iOS","text":"<p>On iOS, you might want to use the Darwin-specific HTTP client:</p> <pre><code>httpClient = HttpClient(Darwin) {\n    install(WebSockets)\n    install(SSE)\n    install(HttpTimeout)\n    install(ContentNegotiation) { json() }\n}\n</code></pre>"},{"location":"user-guide/configuration/#next-steps","title":"Next Steps","text":"<p>Now that you know how to configure SignalRKore, you can learn how to:</p> <ul> <li>Send messages to the hub</li> <li>Receive messages from the hub</li> <li>Work with streams</li> <li>Configure automatic reconnection</li> </ul>"},{"location":"user-guide/connection/","title":"Connection","text":"<p>This guide explains how to establish and manage connections to a SignalR hub using SignalRKore.</p>"},{"location":"user-guide/connection/#creating-a-connection","title":"Creating a Connection","text":"<p>To connect to a SignalR hub, you first need to create a <code>HubConnection</code> instance using the <code>HubConnectionBuilder</code>:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\")\n</code></pre> <p>The URL should point to your SignalR hub endpoint. This is typically the base URL of your web application followed by the hub path (e.g., <code>/chathub</code>).</p>"},{"location":"user-guide/connection/#connection-lifecycle","title":"Connection Lifecycle","text":""},{"location":"user-guide/connection/#starting-a-connection","title":"Starting a Connection","text":"<p>Before you can send or receive messages, you need to start the connection:</p> <pre><code>// In a coroutine scope\nscope.launch {\n    try {\n        connection.start()\n        println(\"Connection started successfully\")\n    } catch (ex: Exception) {\n        println(\"Failed to start connection: ${ex.message}\")\n    }\n}\n</code></pre> <p>The <code>start</code> method is suspending and will complete when the connection is established or throw an exception if the connection fails.</p>"},{"location":"user-guide/connection/#monitoring-connection-state","title":"Monitoring Connection State","text":"<p>You can monitor the connection state using the <code>connectionState</code> property:</p> <pre><code>scope.launch {\n    connection.connectionState.collect { state -&gt;\n        when (state) {\n            HubConnectionState.CONNECTED -&gt; println(\"Connected to the hub\")\n            HubConnectionState.CONNECTING -&gt; println(\"Connecting to the hub\")\n            HubConnectionState.DISCONNECTED -&gt; println(\"Disconnected from the hub\")\n            HubConnectionState.RECONNECTING -&gt; println(\"Reconnecting to the hub\")\n        }\n    }\n}\n</code></pre> <p>This is useful for updating your UI based on the connection state or for implementing custom reconnection logic.</p>"},{"location":"user-guide/connection/#stopping-a-connection","title":"Stopping a Connection","text":"<p>When you're done with the connection, you should stop it to release resources:</p> <pre><code>scope.launch {\n    connection.stop()\n    println(\"Connection stopped\")\n}\n</code></pre> <p>You can optionally provide an error message:</p> <pre><code>scope.launch {\n    connection.stop(\"Connection closed by user\")\n}\n</code></pre>"},{"location":"user-guide/connection/#connection-options","title":"Connection Options","text":"<p>When creating a connection, you can configure various options:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    // Configure connection options here\n}\n</code></pre>"},{"location":"user-guide/connection/#transport","title":"Transport","text":"<p>You can specify which transport to use for the connection:</p> <pre><code>transportEnum = TransportEnum.WebSockets\n</code></pre> <p>Available transport options:</p> <ul> <li><code>TransportEnum.All</code> (default): Automatically selects the best available transport</li> <li><code>TransportEnum.WebSockets</code>: Uses WebSockets transport</li> <li><code>TransportEnum.ServerSentEvents</code>: Uses Server-Sent Events transport</li> <li><code>TransportEnum.LongPolling</code>: Uses Long Polling transport</li> </ul>"},{"location":"user-guide/connection/#skip-negotiate","title":"Skip Negotiate","text":"<p>You can skip the negotiate step when using WebSockets:</p> <pre><code>skipNegotiate = true\n</code></pre> <p>Note: This option can only be used with WebSockets transport.</p>"},{"location":"user-guide/connection/#automatic-reconnect","title":"Automatic Reconnect","text":"<p>You can configure automatic reconnection when the connection is lost:</p> <pre><code>automaticReconnect = AutomaticReconnect.Active\n</code></pre> <p>See Reconnection for more details on reconnection options.</p>"},{"location":"user-guide/connection/#http-headers","title":"HTTP Headers","text":"<p>You can add custom HTTP headers to the connection:</p> <pre><code>headers = mapOf(\n    \"Authorization\" to \"Bearer token\",\n    \"Custom-Header\" to \"Value\"\n)\n</code></pre>"},{"location":"user-guide/connection/#access-token","title":"Access Token","text":"<p>You can provide an access token for authentication:</p> <pre><code>accessTokenProvider = { \"your-access-token\" }\n</code></pre> <p>This is a convenience property that sets the \"Authorization\" header with a \"Bearer\" prefix. It's equivalent to:</p> <pre><code>headers[\"Authorization\"] = \"Bearer your-access-token\"\n</code></pre> <p>This is useful for JWT authentication.</p>"},{"location":"user-guide/connection/#handshake-response-timeout","title":"Handshake Response Timeout","text":"<p>You can configure the timeout for the handshake response:</p> <pre><code>handshakeResponseTimeout = 30.seconds\n</code></pre>"},{"location":"user-guide/connection/#http-client","title":"HTTP Client","text":"<p>You can provide a custom Ktor HTTP client:</p> <pre><code>httpClient = HttpClient {\n    install(WebSockets)\n    install(SSE)\n    install(HttpTimeout)\n    install(ContentNegotiation) { json() }\n}\n</code></pre> <p>This is useful if you need to configure the HTTP client with custom settings or plugins.</p>"},{"location":"user-guide/connection/#protocol","title":"Protocol","text":"<p>You can specify a custom hub protocol:</p> <pre><code>protocol = JsonHubProtocol()\n</code></pre> <p>Currently, only the <code>JsonHubProtocol</code> is supported.</p>"},{"location":"user-guide/connection/#json-serialization","title":"JSON Serialization","text":"<p>You can provide a custom JSON serializer:</p> <pre><code>json = Json {\n    ignoreUnknownKeys = true\n    isLenient = true\n    // Other configuration options\n}\n</code></pre> <p>This is useful if you need to configure the JSON serializer with custom settings or modules.</p>"},{"location":"user-guide/connection/#logger","title":"Logger","text":"<p>You can provide a custom logger:</p> <pre><code>logger = Logger { severity, message, cause -&gt;\n    when (severity) {\n        Logger.Severity.INFO -&gt; println(\"INFO: $message\")\n        Logger.Severity.WARNING -&gt; println(\"WARNING: $message\")\n        Logger.Severity.ERROR -&gt; println(\"ERROR: $message, cause: $cause\")\n    }\n}\n</code></pre>"},{"location":"user-guide/connection/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates how to create, start, monitor, and stop a connection:</p> <pre><code>val scope = CoroutineScope(Dispatchers.Main)\n\n// Create a connection\nval connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    transportEnum = TransportEnum.WebSockets\n    automaticReconnect = AutomaticReconnect.Active\n    headers = mapOf(\"Authorization\" to \"Bearer token\")\n}\n\n// Monitor connection state\nscope.launch {\n    connection.connectionState.collect { state -&gt;\n        println(\"Connection state: $state\")\n    }\n}\n\n// Start the connection\nscope.launch {\n    try {\n        connection.start()\n        println(\"Connection started successfully\")\n\n        // Do something with the connection\n\n        // Stop the connection when done\n        connection.stop()\n    } catch (ex: Exception) {\n        println(\"Failed to start connection: ${ex.message}\")\n    }\n}\n</code></pre>"},{"location":"user-guide/connection/#next-steps","title":"Next Steps","text":"<p>Now that you know how to establish and manage connections, you can learn how to:</p> <ul> <li>Send messages to the hub</li> <li>Receive messages from the hub</li> <li>Work with streams</li> <li>Configure automatic reconnection</li> <li>Explore advanced configuration options</li> </ul>"},{"location":"user-guide/receiving-messages/","title":"Receiving Messages","text":"<p>This guide explains how to receive messages from a SignalR hub using SignalRKore.</p>"},{"location":"user-guide/receiving-messages/#prerequisites","title":"Prerequisites","text":"<p>Before you can receive messages, you need to:</p> <ol> <li>Create a connection using <code>HubConnectionBuilder</code></li> <li>Start the connection using <code>connection.start()</code></li> </ol> <p>See the Connection guide for details.</p>"},{"location":"user-guide/receiving-messages/#on-method","title":"On Method","text":"<p>The <code>on</code> method registers a handler for a specific hub method. It returns a Flow that emits the parameters of the hub method when it's invoked by the server.</p>"},{"location":"user-guide/receiving-messages/#basic-usage","title":"Basic Usage","text":"<pre><code>// Register a handler for a hub method with no parameters\nconnection.on(\"ping\").collect {\n    println(\"Received ping from server\")\n}\n\n// Register a handler for a hub method with one parameter\nconnection.on(\"receiveMessage\", String.serializer()).collect { (message) -&gt;\n    println(\"Received message: $message\")\n}\n\n// Register a handler for a hub method with multiple parameters\nconnection.on(\"broadcastMessage\", String.serializer(), String.serializer()).collect { (user, message) -&gt;\n    println(\"$user says: $message\")\n}\n</code></pre> <p>The first parameter is the name of the hub method to handle, followed by the parameter types of the hub method.</p>"},{"location":"user-guide/receiving-messages/#type-parameters","title":"Type Parameters","text":"<p>You need to specify the type of each parameter that the hub method will receive:</p> <pre><code>// One parameter of type String\nconnection.on(\"receiveMessage\", String.serializer())\n\n// Two parameters: String and Int\nconnection.on(\"receiveScore\", String.serializer(), Int.serializer())\n\n// Three parameters: String, Double, Double\nconnection.on(\"receiveLocation\", String.serializer(), Double.serializer(), Double.serializer())\n</code></pre>"},{"location":"user-guide/receiving-messages/#receiving-complex-types","title":"Receiving Complex Types","text":"<p>You can receive complex types as parameters:</p> <pre><code>@Serializable\ndata class ChatMessage(\n    val user: String,\n    val message: String,\n    val timestamp: String\n)\n\n// Register a handler for a hub method that receives a complex type\nconnection.on(\"receiveMessage\", ChatMessage.serializer()).collect { (message) -&gt;\n    println(\"${message.user} says: ${message.message} at ${message.timestamp}\")\n}\n</code></pre> <p>Note that complex types must be annotated with <code>@Serializable</code> from the Kotlinx Serialization library.</p>"},{"location":"user-guide/receiving-messages/#receiving-collections","title":"Receiving Collections","text":"<p>You can receive collections as parameters:</p> <pre><code>// Receive a list of strings\nconnection.on(\"receiveUsers\", ListSerializer(String.serializer())).collect { (users) -&gt;\n    println(\"Received users: ${users.joinToString(\", \")}\")\n}\n\n// Receive a map\nconnection.on(\"receiveUserRoles\", MapSerializer(Strin.serializer(), String.serializer()).collect { (userRoles) -&gt;\n    println(\"Received user roles: $userRoles\")\n}\n</code></pre>"},{"location":"user-guide/receiving-messages/#returning-results","title":"Returning Results","text":"<p>Some hub methods may expect a result from the client. You can return a result using the <code>on</code> method with a result type:</p> <pre><code>// Register a handler that returns a result\nconnection.on(\"getClientTime\", resultType = String.serializer()) {\n    // Return the current time as a string\n    val currentTime = SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(Date())\n    currentTime\n}\n\n// Register a handler with parameters that returns a result\nconnection.on(\"add\", Int.serializer(), Int.serializer(), resultType = Int.serializer()) { a, b -&gt;\n    // Return the sum of the two parameters\n    a + b\n}\n</code></pre> <p>The <code>resultType</code> parameter specifies the type of the result that the hub method expects.</p>"},{"location":"user-guide/receiving-messages/#handling-errors","title":"Handling Errors","text":"<p>When receiving messages, you should handle potential errors:</p> <pre><code>connection.on(\"receiveMessage\", String.serializer())\n    .catch { ex -&gt;\n        println(\"Error receiving message: ${ex.message}\")\n    }\n    .collect { (message) -&gt;\n        println(\"Received message: $message\")\n    }\n</code></pre> <p>Common errors include:</p> <ul> <li>Connection lost</li> <li>Parameter type mismatch</li> <li>Serialization errors</li> </ul>"},{"location":"user-guide/receiving-messages/#unregistering-handlers","title":"Unregistering Handlers","text":"<p>The <code>on</code> method returns a Flow that you can collect. When you're done collecting, the handler is automatically unregistered.</p> <p>If you need to manually unregister a handler, you can use the <code>cancel</code> method on the coroutine job:</p> <pre><code>val job = scope.launch {\n    connection.on(\"receiveMessage\", String.serializer()).collect { (message) -&gt;\n        println(\"Received message: $message\")\n    }\n}\n\n// Later, when you want to unregister the handler\njob.cancel()\n</code></pre>"},{"location":"user-guide/receiving-messages/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates how to receive messages:</p> <pre><code>val scope = CoroutineScope(Dispatchers.Main)\n\n// Create a connection\nval connection = HubConnectionBuilder.create(\"https://example.com/chathub\")\n\n// Start the connection\nscope.launch {\n    try {\n        connection.start()\n        println(\"Connection started successfully\")\n\n        // Register a handler for a hub method with multiple parameters\n        launch {\n            connection.on(\"broadcastMessage\", String.serializer(), String.serializer())\n                .catch { ex -&gt;\n                    println(\"Error receiving message: ${ex.message}\")\n                }\n                .collect { (user, message) -&gt;\n                    println(\"$user says: $message\")\n                }\n        }\n\n        // Register a handler for a hub method that receives a complex type\n        launch {\n            connection.on(\"receiveMessage\", ChatMessage.serializer()).collect { (message) -&gt;\n                println(\"${message.user} says: ${message.message} at ${message.timestamp}\")\n            }\n        }\n\n        // Register a handler that returns a result\n        connection.on(\"getClientTime\", resultType = String.serializer()) {\n            val currentTime = SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(Date())\n            currentTime\n        }\n\n        // Keep the connection open\n        delay(Long.MAX_VALUE)\n    } catch (ex: Exception) {\n        println(\"Error: ${ex.message}\")\n    }\n}\n</code></pre>"},{"location":"user-guide/receiving-messages/#next-steps","title":"Next Steps","text":"<p>Now that you know how to receive messages, you can learn how to:</p> <ul> <li>Send messages to the hub</li> <li>Work with streams</li> <li>Configure automatic reconnection</li> <li>Explore advanced configuration options</li> </ul>"},{"location":"user-guide/reconnection/","title":"Reconnection","text":"<p>This guide explains how to configure automatic reconnection in SignalRKore. Automatic reconnection allows the client to reconnect to the server when the connection is lost.</p>"},{"location":"user-guide/reconnection/#prerequisites","title":"Prerequisites","text":"<p>Before you can configure reconnection, you need to:</p> <ol> <li>Create a connection using <code>HubConnectionBuilder</code></li> <li>Configure the reconnection policy</li> <li>Start the connection using <code>connection.start()</code></li> </ol> <p>See the Connection guide for details.</p>"},{"location":"user-guide/reconnection/#reconnection-policies","title":"Reconnection Policies","text":"<p>SignalRKore provides several reconnection policies:</p>"},{"location":"user-guide/reconnection/#inactive-default","title":"Inactive (Default)","text":"<p>By default, automatic reconnection is disabled:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    automaticReconnect = AutomaticReconnect.Inactive\n}\n</code></pre> <p>With this policy, when the connection is lost, the client will not attempt to reconnect automatically. You'll need to manually call <code>connection.start()</code> to reconnect.</p>"},{"location":"user-guide/reconnection/#active-basic","title":"Active (Basic)","text":"<p>The basic reconnection policy attempts to reconnect with a fixed delay pattern:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    automaticReconnect = AutomaticReconnect.Active\n}\n</code></pre> <p>With this policy, when the connection is lost, the client will attempt to reconnect with the following delays:</p> <ol> <li>0 seconds (immediate)</li> <li>2 seconds</li> <li>10 seconds</li> <li>30 seconds</li> </ol> <p>If all four attempts fail, the client will stop trying to reconnect, and the connection state will change to <code>DISCONNECTED</code>.</p>"},{"location":"user-guide/reconnection/#exponential-backoff","title":"Exponential Backoff","text":"<p>The exponential backoff policy attempts to reconnect with increasing delays:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    automaticReconnect = AutomaticReconnect.exponentialBackoff()\n}\n</code></pre> <p>With this policy, when the connection is lost, the client will attempt to reconnect with exponentially increasing delays. By default:</p> <ul> <li>Initial delay: 1 second</li> <li>Multiplier: 1.5 (each delay is 1.5 times longer than the previous one)</li> <li>Maximum delay: 60 seconds</li> <li>Maximum attempts: 15</li> </ul> <p>You can customize these parameters:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    automaticReconnect = AutomaticReconnect.exponentialBackoff(\n        initialDelayMillis = 2000,  // 2 seconds\n        maxDelayMillis = 30000,     // 30 seconds\n        multiplier = 2.0,           // Double the delay each time\n        maxAttempts = 10            // Maximum 10 attempts\n    )\n}\n</code></pre>"},{"location":"user-guide/reconnection/#custom","title":"Custom","text":"<p>You can create a custom reconnection policy by implementing the <code>AutomaticReconnect.Custom</code> class:</p> <pre><code>val connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    automaticReconnect = AutomaticReconnect.Custom { previousRetryCount, elapsedTime -&gt;\n        when (previousRetryCount) {\n            0 -&gt; 0L                 // Immediate retry\n            1 -&gt; 1000L              // 1 second\n            2 -&gt; 5000L              // 5 seconds\n            3 -&gt; 10000L             // 10 seconds\n            else -&gt; null            // Stop retrying\n        }\n    }\n}\n</code></pre> <p>The custom policy function takes two parameters:</p> <ul> <li><code>previousRetryCount</code>: The number of previous retry attempts (0-based)</li> <li><code>elapsedTime</code>: The time elapsed since the first reconnection attempt</li> </ul> <p>The function should return:</p> <ul> <li>A delay in milliseconds for the next reconnection attempt</li> <li><code>null</code> to stop retrying</li> </ul>"},{"location":"user-guide/reconnection/#monitoring-reconnection","title":"Monitoring Reconnection","text":"<p>You can monitor the connection state to track reconnection attempts:</p> <pre><code>connection.connectionState.collect { state -&gt;\n    when (state) {\n        HubConnectionState.CONNECTED -&gt; println(\"Connected to the hub\")\n        HubConnectionState.CONNECTING -&gt; println(\"Connecting to the hub\")\n        HubConnectionState.DISCONNECTED -&gt; println(\"Disconnected from the hub\")\n        HubConnectionState.RECONNECTING -&gt; println(\"Reconnecting to the hub\")\n    }\n}\n</code></pre> <p>When the connection is lost and automatic reconnection is enabled, the connection state will change to <code>RECONNECTING</code>. If reconnection is successful, the state will change to <code>CONNECTED</code>. If all reconnection attempts fail, the state will change to <code>DISCONNECTED</code>.</p>"},{"location":"user-guide/reconnection/#server-initiated-reconnection","title":"Server-Initiated Reconnection","text":"<p>SignalR Core servers can send a close message with <code>allowReconnect</code> set to <code>true</code>. When this happens, SignalRKore will attempt to reconnect according to the configured reconnection policy.</p>"},{"location":"user-guide/reconnection/#manual-reconnection","title":"Manual Reconnection","text":"<p>If automatic reconnection is disabled or all reconnection attempts fail, you can manually reconnect:</p> <pre><code>if (connection.connectionState.value == HubConnectionState.DISCONNECTED) {\n    try {\n        connection.start()\n        println(\"Reconnected successfully\")\n    } catch (ex: Exception) {\n        println(\"Failed to reconnect: ${ex.message}\")\n    }\n}\n</code></pre>"},{"location":"user-guide/reconnection/#handling-reconnection-events","title":"Handling Reconnection Events","text":"<p>You can handle reconnection events by monitoring the connection state:</p> <pre><code>var previousState = HubConnectionState.DISCONNECTED\n\nconnection.connectionState.collect { state -&gt;\n    when (state) {\n        HubConnectionState.CONNECTED -&gt; {\n            if (previousState == HubConnectionState.RECONNECTING) {\n                println(\"Reconnected successfully\")\n                // Re-subscribe to hub methods or perform other initialization\n            } else {\n                println(\"Connected to the hub\")\n            }\n        }\n        HubConnectionState.RECONNECTING -&gt; {\n            println(\"Connection lost, attempting to reconnect\")\n            // Handle reconnection attempt\n        }\n        HubConnectionState.DISCONNECTED -&gt; {\n            if (previousState == HubConnectionState.RECONNECTING) {\n                println(\"Failed to reconnect\")\n                // Handle reconnection failure\n            } else {\n                println(\"Disconnected from the hub\")\n            }\n        }\n        else -&gt; println(\"Connection state: $state\")\n    }\n    previousState = state\n}\n</code></pre>"},{"location":"user-guide/reconnection/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates how to configure and handle reconnection:</p> <pre><code>val scope = CoroutineScope(Dispatchers.Main)\n\n// Create a connection with automatic reconnection\nval connection = HubConnectionBuilder.create(\"https://example.com/chathub\") {\n    automaticReconnect = AutomaticReconnect.exponentialBackoff(\n        initialDelayMillis = 1000,  // 1 second\n        maxDelayMillis = 30000,     // 30 seconds\n        multiplier = 1.5,           // 1.5x multiplier\n        maxAttempts = 10            // Maximum 10 attempts\n    )\n}\n\n// Monitor connection state\nvar previousState = HubConnectionState.DISCONNECTED\nscope.launch {\n    connection.connectionState.collect { state -&gt;\n        when (state) {\n            HubConnectionState.CONNECTED -&gt; {\n                if (previousState == HubConnectionState.RECONNECTING) {\n                    println(\"Reconnected successfully\")\n                    // Re-subscribe to hub methods or perform other initialization\n                } else {\n                    println(\"Connected to the hub\")\n                }\n            }\n            HubConnectionState.RECONNECTING -&gt; {\n                println(\"Connection lost, attempting to reconnect\")\n                // Handle reconnection attempt\n            }\n            HubConnectionState.DISCONNECTED -&gt; {\n                if (previousState == HubConnectionState.RECONNECTING) {\n                    println(\"Failed to reconnect\")\n                    // Handle reconnection failure\n                } else {\n                    println(\"Disconnected from the hub\")\n                }\n            }\n            else -&gt; println(\"Connection state: $state\")\n        }\n        previousState = state\n    }\n}\n\n// Start the connection\nscope.launch {\n    try {\n        connection.start()\n        println(\"Connection started successfully\")\n\n        // Keep the connection open\n        delay(Long.MAX_VALUE)\n    } catch (ex: Exception) {\n        println(\"Error: ${ex.message}\")\n    }\n}\n</code></pre>"},{"location":"user-guide/reconnection/#next-steps","title":"Next Steps","text":"<p>Now that you know how to configure reconnection, you can learn how to:</p> <ul> <li>Send messages to the hub</li> <li>Receive messages from the hub</li> <li>Work with streams</li> <li>Explore advanced configuration options</li> </ul>"},{"location":"user-guide/sending-messages/","title":"Sending Messages","text":"<p>This guide explains how to send messages to a SignalR hub using SignalRKore.</p>"},{"location":"user-guide/sending-messages/#prerequisites","title":"Prerequisites","text":"<p>Before you can send messages, you need to:</p> <ol> <li>Create a connection using <code>HubConnectionBuilder</code></li> <li>Start the connection using <code>connection.start()</code></li> </ol> <p>See the Connection guide for details.</p>"},{"location":"user-guide/sending-messages/#send-method","title":"Send Method","text":"<p>The <code>send</code> method sends a message to the hub without expecting a response:</p> <pre><code>// Send a message with no parameters\nconnection.send(\"ping\")\n\n// Send a message with parameters\nconnection.send(\"broadcastMessage\", \"User\", \"Hello, SignalR!\")\n\n// Send a message with multiple parameters\nconnection.send(\"sendCoordinates\", \"User\", 10.5, 20.3, \"Location\")\n</code></pre> <p>The first parameter is the name of the hub method to call, followed by any parameters to pass to the method.</p>"},{"location":"user-guide/sending-messages/#invoke-method","title":"Invoke Method","text":"<p>The <code>invoke</code> method sends a message to the hub and expects a response:</p> <pre><code>// Invoke a method and get the result\nval result = connection.invoke(\"echo\", String.serializer(), \"Hello, SignalR!\")\nprintln(\"Server responded: $result\")\n\n// Invoke a method with multiple parameters\nval sum = connection.invoke(\"add\", Int.serializer(), 5, 10)\nprintln(\"Sum: $sum\")\n</code></pre> <p>The first parameter is the name of the hub method to call, the second parameter is the expected return type, followed by any parameters to pass to the method.</p>"},{"location":"user-guide/sending-messages/#sending-complex-types","title":"Sending Complex Types","text":"<p>You can send complex types as parameters:</p> <pre><code>@Serializable\ndata class ChatMessage(\n    val user: String,\n    val message: String,\n    val timestamp: String\n)\n\nval message = ChatMessage(\n    user = \"User\",\n    message = \"Hello, SignalR!\",\n    timestamp = \"2023-01-01T12:00:00Z\"\n)\n\n// Send a complex type\nconnection.send(\"sendMessage\", message)\n\n// Invoke a method with a complex type\nval response = connection.invoke(\"echoMessage\", ChatMessage.serializer(), message)\nprintln(\"Server echoed: ${response.message}\")\n</code></pre> <p>Note that complex types must be annotated with <code>@Serializable</code> from the Kotlinx Serialization library.</p>"},{"location":"user-guide/sending-messages/#sending-collections","title":"Sending Collections","text":"<p>You can send collections as parameters:</p> <pre><code>// Send a list\nval users = listOf(\"User1\", \"User2\", \"User3\")\nconnection.send(\"addUsers\", users)\n\n// Send a map\nval userRoles = mapOf(\"User1\" to \"Admin\", \"User2\" to \"User\")\nconnection.send(\"setUserRoles\", userRoles)\n</code></pre>"},{"location":"user-guide/sending-messages/#sending-streams","title":"Sending Streams","text":"<p>You can send streams of data to the hub using Kotlin Flows:</p> <pre><code>// Create a flow that emits 10 integers with a 1-second delay between each\nval dataStream = flow {\n    for (i in 1..10) {\n        emit(i)\n        delay(1000)\n    }\n}\n\n// Send the stream to the hub\nconnection.send(\"uploadStream\", dataStream)\n</code></pre> <p>See the Streams guide for more details on working with streams.</p>"},{"location":"user-guide/sending-messages/#error-handling","title":"Error Handling","text":"<p>When sending messages, you should handle potential errors:</p> <pre><code>try {\n    connection.send(\"broadcastMessage\", \"User\", \"Hello, SignalR!\")\n} catch (ex: Exception) {\n    println(\"Failed to send message: ${ex.message}\")\n}\n</code></pre> <p>Common errors include:</p> <ul> <li>Connection not established</li> <li>Hub method not found</li> <li>Parameter type mismatch</li> <li>Server-side errors</li> </ul>"},{"location":"user-guide/sending-messages/#connection-state-check","title":"Connection State Check","text":"<p>The <code>send</code> and <code>invoke</code> methods automatically check if the connection is in the <code>CONNECTED</code> state before sending a message. If the connection is not connected, they will throw an exception.</p> <p>You can manually check the connection state:</p> <pre><code>if (connection.connectionState.value == HubConnectionState.CONNECTED) {\n    connection.send(\"broadcastMessage\", \"User\", \"Hello, SignalR!\")\n} else {\n    println(\"Cannot send message: Connection is not connected\")\n}\n</code></pre>"},{"location":"user-guide/sending-messages/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates how to send messages:</p> <pre><code>val scope = CoroutineScope(Dispatchers.Main)\n\n// Create a connection\nval connection = HubConnectionBuilder.create(\"https://example.com/chathub\")\n\n// Start the connection\nscope.launch {\n    try {\n        connection.start()\n        println(\"Connection started successfully\")\n\n        // Send a message\n        connection.send(\"broadcastMessage\", \"User\", \"Hello, SignalR!\")\n\n        // Invoke a method and get the result\n        val result = connection.invoke(\"echo\", String.serializer(), \"Hello, SignalR!\")\n        println(\"Server responded: $result\")\n\n        // Send a complex type\n        val message = ChatMessage(\n            user = \"User\",\n            message = \"Hello, SignalR!\",\n            timestamp = \"2023-01-01T12:00:00Z\"\n        )\n        connection.send(\"sendMessage\", message)\n\n        // Send a stream\n        val dataStream = flow {\n            for (i in 1..10) {\n                emit(i)\n                delay(1000)\n            }\n        }\n        connection.send(\"uploadStream\", dataStream)\n\n        // Stop the connection when done\n        connection.stop()\n    } catch (ex: Exception) {\n        println(\"Error: ${ex.message}\")\n    }\n}\n</code></pre>"},{"location":"user-guide/sending-messages/#next-steps","title":"Next Steps","text":"<p>Now that you know how to send messages, you can learn how to:</p> <ul> <li>Receive messages from the hub</li> <li>Work with streams</li> <li>Configure automatic reconnection</li> <li>Explore advanced configuration options</li> </ul>"},{"location":"user-guide/streams/","title":"Streams","text":"<p>This guide explains how to work with streams in SignalRKore. Streams allow you to send and receive a sequence of data over time, rather than a single message.</p>"},{"location":"user-guide/streams/#prerequisites","title":"Prerequisites","text":"<p>Before you can work with streams, you need to:</p> <ol> <li>Create a connection using <code>HubConnectionBuilder</code></li> <li>Start the connection using <code>connection.start()</code></li> </ol> <p>See the Connection guide for details.</p>"},{"location":"user-guide/streams/#receiving-streams","title":"Receiving Streams","text":"<p>The <code>stream</code> method allows you to receive a stream of data from the hub. It returns a Flow that emits items from the stream as they arrive.</p>"},{"location":"user-guide/streams/#basic-usage","title":"Basic Usage","text":"<pre><code>// Receive a stream of integers\nconnection.stream(\"counter\", Int.serializer()).collect { count -&gt;\n    println(\"Received count: $count\")\n}\n</code></pre> <p>The first parameter is the name of the hub method to call, and the second parameter is the type of items in the stream. This is the most basic form of receiving a stream from the hub.</p>"},{"location":"user-guide/streams/#stream-parameters","title":"Stream Parameters","text":"<p>You can pass parameters to the stream method:</p> <pre><code>// Stream with parameters\nconnection.stream(\"generateNumbers\", Int.serializer(), 1, 10, 500).collect { number -&gt;\n    println(\"Received number: $number\")\n}\n</code></pre> <p>In this example, we're calling a hub method named \"generateNumbers\" that returns a stream of integers. We're passing three parameters: 1 (the start value), 10 (the end value), and 500 (the delay between items in milliseconds).</p>"},{"location":"user-guide/streams/#receiving-complex-types","title":"Receiving Complex Types","text":"<p>You can receive streams of complex types:</p> <pre><code>@Serializable\ndata class StockPrice(\n    val symbol: String,\n    val price: Double,\n    val timestamp: String\n)\n\n// Receive a stream of stock prices\nconnection.stream(\"stockPrices\", StockPrice.serializer(), \"AAPL\", \"MSFT\", \"GOOG\").collect { price -&gt;\n    println(\"${price.symbol}: ${price.price} at ${price.timestamp}\")\n}\n</code></pre> <p>Note that complex types must be annotated with <code>@Serializable</code> from the Kotlinx Serialization library.</p>"},{"location":"user-guide/streams/#handling-stream-completion","title":"Handling Stream Completion","text":"<p>The stream completes when the server completes the stream or when an error occurs:</p> <pre><code>connection.stream(\"counter\", Int.serializer(), 10, 1000)\n    .catch { ex -&gt;\n        println(\"Stream error: ${ex.message}\")\n    }\n    .collect { count -&gt;\n        println(\"Received count: $count\")\n    }\n</code></pre>"},{"location":"user-guide/streams/#cancelling-a-stream","title":"Cancelling a Stream","text":"<p>You can cancel a stream by cancelling the coroutine job:</p> <pre><code>val job = scope.launch {\n    connection.stream(\"counter\", Int.serializer(), 10, 1000).collect { count -&gt;\n        println(\"Received count: $count\")\n    }\n}\n\n// Later, when you want to cancel the stream\njob.cancel()\n</code></pre>"},{"location":"user-guide/streams/#sending-streams","title":"Sending Streams","text":"<p>You can send a stream of data to the hub using a Flow:</p> <pre><code>// Create a flow that emits 10 integers with a 1-second delay between each\nval dataStream = flow {\n    for (i in 1..10) {\n        emit(i)\n        delay(1000)\n    }\n}\n\n// Send the stream to the hub\nconnection.send(\"uploadStream\", dataStream)\n</code></pre>"},{"location":"user-guide/streams/#sending-complex-types","title":"Sending Complex Types","text":"<p>You can send streams of complex types:</p> <pre><code>@Serializable\ndata class DataPoint(\n    val value: Double,\n    val timestamp: String\n)\n\n// Create a flow of data points\nval dataStream = flow {\n    for (i in 1..10) {\n        val dataPoint = DataPoint(\n            value = Random.nextDouble(0.0, 100.0),\n            timestamp = SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(Date())\n        )\n        emit(dataPoint)\n        delay(1000)\n    }\n}\n\n// Send the stream to the hub\nconnection.send(\"uploadDataPoints\", dataStream)\n</code></pre>"},{"location":"user-guide/streams/#stream-completion","title":"Stream Completion","text":"<p>The stream completes when the Flow completes:</p> <pre><code>val dataStream = flow {\n    for (i in 1..10) {\n        emit(i)\n        delay(1000)\n    }\n}\n\nconnection.send(\"uploadStream\", dataStream)\n</code></pre>"},{"location":"user-guide/streams/#error-handling","title":"Error Handling","text":"<p>When working with streams, you should handle potential errors:</p> <pre><code>// Receiving streams\nconnection.stream(\"counter\", Int.serializer(), 10, 1000)\n    .catch { ex -&gt;\n        println(\"Stream error: ${ex.message}\")\n    }\n    .collect { count -&gt;\n        println(\"Received count: $count\")\n    }\n\n// Sending streams\nval dataStream = flow {\n    try {\n        for (i in 1..10) {\n            emit(i)\n            delay(1000)\n        }\n    } catch (ex: Exception) {\n        println(\"Stream error: ${ex.message}\")\n    }\n}\n\ntry {\n    connection.send(\"uploadStream\", dataStream)\n} catch (ex: Exception) {\n    println(\"Failed to send stream: ${ex.message}\")\n}\n</code></pre> <p>Common errors include:</p> <ul> <li>Connection lost</li> <li>Stream cancelled</li> <li>Parameter type mismatch</li> <li>Serialization errors</li> </ul>"},{"location":"user-guide/streams/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates how to work with streams:</p> <pre><code>val scope = CoroutineScope(Dispatchers.Main)\n\n// Create a connection\nval connection = HubConnectionBuilder.create(\"https://example.com/chathub\")\n\n// Start the connection\nscope.launch {\n    try {\n        connection.start()\n        println(\"Connection started successfully\")\n\n        // Receive a stream\n        launch {\n            connection.stream(\"counter\", Int.serializer(), 10, 1000)\n                .catch { ex -&gt;\n                    println(\"Stream error: ${ex.message}\")\n                }\n                .collect { count -&gt;\n                    println(\"Received count: $count\")\n                }\n        }\n\n        // Send a stream\n        val dataStream = flow {\n            for (i in 1..10) {\n                emit(i)\n                delay(1000)\n            }\n        }\n\n        connection.send(\"uploadStream\", dataStream)\n\n        // Keep the connection open\n        delay(Long.MAX_VALUE)\n    } catch (ex: Exception) {\n        println(\"Error: ${ex.message}\")\n    }\n}\n</code></pre>"},{"location":"user-guide/streams/#next-steps","title":"Next Steps","text":"<p>Now that you know how to work with streams, you can learn how to:</p> <ul> <li>Send messages to the hub</li> <li>Receive messages from the hub</li> <li>Configure automatic reconnection</li> <li>Explore advanced configuration options</li> </ul>"}]}